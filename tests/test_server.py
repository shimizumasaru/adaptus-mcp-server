#!/usr/bin/env python3
"""
Test suite for Adaptus MCP Server
Generated by Adaptus MCP Server
"""

import json
import os
import sys
from pathlib import Path
from unittest.mock import Mock, patch

import pytest

# Add src to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "src"))

try:
    from adaptus.server import (
        _basic_metrics,
        _read_code,
        _read_resource,
        _read_template,
        _score_formula,
        _semantic_analysis,
        analyze_debt,
        generate_tests,
        get_core_prompts,
        get_formula,
        get_guidelines,
        score_debt,
        summarize,
    )
except ImportError as e:
    pytest.skip(f"Cannot import server module: {e}", allow_module_level=True)


class TestResourceFunctions:
    """Test resource reading functions"""

    def test_read_code_file_exists(self, tmp_path):
        """Test reading existing code file"""
        test_file = tmp_path / "test.py"
        test_file.write_text("print('hello')")

        result = _read_code(test_file)
        assert result == "print('hello')"

    def test_read_code_file_not_exists(self):
        """Test reading non-existent file"""
        fake_path = Path("/non/existent/file.py")
        with pytest.raises(FileNotFoundError):
            _read_code(fake_path)

    def test_read_resource_exists(self):
        """Test reading existing resource"""
        result = _read_resource("guidelines.md")
        assert "設計ガイドライン" in result
        assert "# Version:" in result

    def test_read_resource_not_exists(self):
        """Test reading non-existent resource"""
        result = _read_resource("nonexistent.md")
        assert "Resource not found" in result

    def test_read_template_exists(self):
        """Test reading existing template"""
        result = _read_template("core/debt-analysis.md")
        assert "Technical Debt Analysis" in result

    def test_read_template_with_variables(self):
        """Test template with variable substitution"""
        template_content = "Hello {name}, welcome to {project}!"

        with patch("adaptus.server.Path") as mock_path:
            mock_file = Mock()
            mock_file.read_text.return_value = template_content
            # Mock the path chain: Path(__file__).parent / "templates" / template_path
            # Break line to satisfy linter
            templates_dir = mock_path.return_value.parent.__truediv__.return_value
            templates_dir.__truediv__.return_value = mock_file
            mock_file.exists.return_value = True

            result = _read_template(
                "core/test.md", {"name": "Alice", "project": "Adaptus"}
            )
            assert result == "Hello Alice, welcome to Adaptus!"


class TestAnalysisFunctions:
    """Test code analysis functions"""

    def test_basic_metrics_valid_code(self):
        """Test metrics analysis with valid Python code"""
        code = """
def test_function(a, b):
    if a > b:
        return a
    else:
        return b

class TestClass:
    def method1(self):
        pass

    def method2(self, x, y, z):
        if x:
            for i in range(10):
                if i > 5:
                    break
        return y + z
"""
        result = _basic_metrics(code)

        assert result["loc"] > 0
        assert result["funcs"] == 3
        assert result["branches"] > 0
        assert result["avg_args"] > 0

    def test_basic_metrics_syntax_error(self):
        """Test metrics analysis with invalid Python code"""
        code = "def invalid_syntax(\n    # missing closing parenthesis"
        result = _basic_metrics(code)

        assert result["loc"] > 0
        assert result["funcs"] == 0
        assert result["branches"] == 0
        assert result["avg_args"] == 0.0

    def test_semantic_analysis_valid_code(self):
        """Test semantic analysis with valid code"""
        code = """
def long_function():
    # This function is intentionally long
    x = 1
    y = 2
    # ... many more lines
    return x + y

def too_many_params(a, b, c, d, e, f, g, h):
    return a + b + c + d + e + f + g + h

class LargeClass:
    def method1(self): pass
    def method2(self): pass
    # ... many more methods
    def method25(self): pass
"""
        result = _semantic_analysis(code)

        assert "issues" in result
        assert "smells" in result
        assert "patterns" in result
        assert "summary" in result

        # Should detect issues
        assert len(result["issues"]) > 0
        assert any(issue["type"] == "too_many_params" for issue in result["issues"])

    def test_score_formula(self):
        """Test debt score calculation"""
        metrics = {"mi": 80.0, "branches": 15.0, "dup_rate": 0.1, "td_ratio": 0.05}
        score = _score_formula(metrics)

        assert 0 <= score <= 10
        assert isinstance(score, float)


class TestMcpTools:
    """Test MCP tool functions"""

    def test_analyze_debt_valid_file(self, tmp_path):
        """Test analyze_debt with valid file"""
        test_file = tmp_path / "test.py"
        test_file.write_text(
            """
def test_func():
    return "hello"

class TestClass:
    def method(self):
        pass
"""
        )

        result = analyze_debt([str(test_file)])

        assert str(test_file) in result
        assert "score" in result[str(test_file)]
        assert "loc" in result[str(test_file)]

    def test_analyze_debt_with_semantic(self, tmp_path):
        """Test analyze_debt with semantic analysis enabled"""
        test_file = tmp_path / "test.py"
        test_file.write_text(
            """
def too_many_params(a, b, c, d, e, f, g, h):
    return a + b + c + d + e + f + g + h
"""
        )

        result = analyze_debt([str(test_file)], include_semantic=True)

        assert str(test_file) in result
        assert "semantic_analysis" in result[str(test_file)]
        assert result[str(test_file)]["score"] > 0

    def test_score_debt_tool(self):
        """Test score_debt tool function"""
        metrics = {"loc": 100.0, "funcs": 5.0, "branches": 10.0, "avg_args": 2.0}
        result = score_debt(metrics)

        assert "score" in result
        assert "breakdown" in result
        assert "weights" in result
        assert "severity" in result
        assert result["severity"] in ["low", "medium", "high"]

    def test_generate_tests_pytest(self):
        """Test generate_tests with pytest framework"""
        result = generate_tests("example", "pytest")

        assert "template" in result
        assert "framework" in result
        assert "test_type" in result
        assert "instructions" in result
        assert "next_steps" in result

        assert result["framework"] == "pytest"
        assert "class TestExample" in result["template"]
        assert "import pytest" in result["template"]

    def test_generate_tests_unittest(self):
        """Test generate_tests with unittest framework"""
        result = generate_tests("example", "unittest")

        assert result["framework"] == "unittest"
        assert "class TestExample(unittest.TestCase)" in result["template"]
        assert "import unittest" in result["template"]

    def test_generate_tests_integration(self):
        """Test generate_tests with integration test type"""
        result = generate_tests("example_module", "pytest", "integration")

        assert result["test_type"] == "integration"
        assert "Integration" in result["template"]
        assert "setup_integration" in result["template"]

    def test_summarize_repository(self, tmp_path):
        """Test summarize repository function"""
        # Create test Python files
        (tmp_path / "file1.py").write_text("def func1(): pass")
        (tmp_path / "file2.py").write_text(
            """
class TestClass:
    def method1(self): pass
    def method2(self): pass
"""
        )

        result = summarize(str(tmp_path))

        assert "repository" in result
        assert "summary" in result
        assert "hotspots" in result
        assert "recommendations" in result
        assert "next_steps" in result

        assert result["summary"]["total_files"] == 2
        assert result["summary"]["total_loc"] > 0


class TestMcpResources:
    """Test MCP resource functions"""

    def test_get_formula_resource(self):
        """Test formula resource"""
        result = get_formula()
        data = json.loads(result)

        assert "weights" in data
        assert "note" in data
        assert data["weights"]["mi"] == 0.35

    def test_get_guidelines_resource(self):
        """Test guidelines resource"""
        result = get_guidelines()

        assert "設計ガイドライン" in result
        assert "Pythonコード品質基準" in result
        assert "# Version:" in result

    def test_get_core_prompts_resource(self):
        """Test core prompts resource"""
        result = get_core_prompts()

        assert "コアプロンプトテンプレート集" in result
        assert "技術的負債分析テンプレート" in result


class TestEdgeCases:
    """Test edge cases and error handling"""

    def test_empty_code_metrics(self):
        """Test metrics with empty code"""
        result = _basic_metrics("")
        assert result["loc"] == 0
        assert result["funcs"] == 0

    def test_analyze_debt_nonexistent_file(self):
        """Test analyze_debt with non-existent file"""
        result = analyze_debt(["/non/existent/file.py"])
        assert "/non/existent/file.py" in result
        assert result["/non/existent/file.py"]["error"] == 1.0

    def test_summarize_empty_directory(self, tmp_path):
        """Test summarize with empty directory"""
        result = summarize(str(tmp_path))
        assert "error" in result
        assert "No Python files found" in result["error"]

    def test_generate_tests_custom_framework(self):
        """Test generate_tests with custom framework"""
        result = generate_tests("example_module", "custom_framework")

        assert result["framework"] == "custom_framework"
        assert "custom_framework" in result["template"]


if __name__ == "__main__":
    pytest.main([__file__])
